---
title: "Creating a catalogue of translatables"
output: rmarkdown::html_vignette
description: >
  Learn how pkgdown's automatic linking works, and how you can 
  customise it.
vignette: >
  %\VignetteIndexEntry{Creating a catalogue of translatables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Use case

* We want to create a catalogue (data frame)
* With all translatable texts of a survey and
* Ordered by `group_order` and `question_order`
* For groups it should contain
  * `group_name`
  * `description`
* For questions it should contain
  * `question`
  * `help`
  * Whether it is a sub-question (`parent_qid != 0`)
  * If it is a sub-question, `parent_qid` must be preserved in a way
* For list questions it should contain all answer options
  * `answerText`
  * `answerCode` must be preserved in a way
  * It must be connected to its question

The catalogue should then be sent to a translator who will return it with
replaced texts. Those texts should then be sent to the LimeSurvey application.

## Design

How could the catalogue look like?

| Text ID | Source text | Target text |
|---|---|---|
| `paste0()` | "A group title" | "Ein Gruppentitel" |
| â€¦ |  |  |

## Environment preparation

```{r}
if (!require("tidyverse")) install.packages("tidyverse")
library(tidyverse)

if (!require("LimeRick")) {
  if (!require("devtools")) install.packages("devtools")
  devtools::install_github("k127/LimeRick")
}
library(LimeRick)
```


## Set up survey ID and source language

```{r}
# The ID of the to be translated survey
surveyID = "259165"

# Let's say that our translation workflow has English as the source language
lang = "en"
```


# Get a session key for our future requests

```{r}
lsGetSessionKey()
```


## Get the group list

```{r}
# Note that the field group order has to be numerical for the arrangement to work
groups <- arrange(lsListGroups(surveyID = surveyID, setTypes = TRUE), group_order)
```


## Get the question list

```{r}
questions <- arrange(lsListQuestions(surveyID = surveyID, lang = lang,
                                     setTypes = TRUE), question_order)
```

# TODO suggest package "rapport"

## Read front / back matter from file

Set the path to front matter html files like that:
`options(front_matter_path = "./path/to/my/front/matter/files")`

```{r}

.front_matter <- list(
  welcome = read_file(paste(getOption("front_matter_path"), "welcome.html", sep = "/")),
  policy_label = read_file(paste(getOption("front_matter_path"), "survey_data_policy_label.html", sep = "/")),
  policy_notice = read_file(paste(getOption("front_matter_path"), "survey_data_policy_notice.html", sep = "/")))
```

## Iterate over groups, questions

```{r}
# TODO put functions here
```

```{r}
.ignore_questions <- c("Q1BX")
.other_replace_texts <- list(
  Q1C3 = "Postcode",
  Q2B1 = "Amount",
  Q5A1 = "Other, specify:")

# Create an empty data frame
.key_text_id = "text_id"
.key_source_text = "source_text"
.key_target_text = "target_text"
.col_names = c(.key_text_id, .key_source_text, .key_target_text)
catalogue <- read.table(text = "",
                        colClasses = c("character", "character", "character"),
                        col.names = .col_names)

# add front matter
for (.front_matter_item_key in names(.front_matter)){
  .front_matter_item_value <- .front_matter[.front_matter_item_key]
  .df_row = data.frame(paste0("FRONTMATTER___", .front_matter_item_key), .front_matter_item_value, "")
  names(.df_row) = .col_names
  catalogue = rbind(catalogue, .df_row)
}

# TODO add back matter

for (.i in 1:nrow(groups)) {
  .gid = groups[.i,]$gid
  
  # add group_name to catalogue
  # TODO if source_text exists, only append text_id
  .group_name =  groups[.i,]$group_name
  if (trimws(.group_name) != "") {
    .df_row_group_name = data.frame(paste0("GID___", .gid, "___group_name"), .group_name, "")
    names(.df_row_group_name) = .col_names
    catalogue = rbind(catalogue, .df_row_group_name)
  }

  # add description to catalogue
  # TODO if source_text exists, only append text_id
  .group_description = groups[.i,]$description
  if (trimws(.group_description) != "") {
    .df_row_group_description = data.frame(paste0("GID___", .gid, "___description"), .group_description, "")
    names(.df_row_group_description) = .col_names
    catalogue = rbind(catalogue, .df_row_group_description)
  }

  .group_questions = arrange(filter(questions, gid == .gid, parent_qid == 0), question_order)
  for (.k in 1:nrow(.group_questions)) {
    .qid = .group_questions[.k,]$qid
    .title = .group_questions[.k,]$title

    # skip question if title in ignore list
    if (.title %in% .ignore_questions) next

    # catch question
    # TODO if source_text exists, only append text_id
    .question = .group_questions[.k,]$question
    if (trimws(.question) != "") {
      .df_row_questionn = data.frame(paste0(.title, "___question"), .question, "")
      names(.df_row_questionn) = .col_names
      catalogue = rbind(catalogue, .df_row_questionn)
    }

    # catch help
    # TODO if source_text exists, only append text_id
    .help = .group_questions[.k,]$help
    if (!is.na(.help) && trimws(.help) != "") {
      .df_row_help = data.frame(paste0(.title, "___help"), .help, "")
      names(.df_row_help) = .col_names
      catalogue = rbind(catalogue, .df_row_help)
    }

    # add "other_replace_text"
    if (.title %in% names(.other_replace_texts)) {
      .other_replace_text = .other_replace_texts[[.title]]
      .df_row_other_replace_text = data.frame(paste0(.title, "___other_field"), .other_replace_text, "")
      names(.df_row_other_replace_text) = .col_names
      catalogue = rbind(catalogue, .df_row_other_replace_text)
    }

    # answer options
    if (.group_questions[.k,]$type %in% c("L", "!", "F")) {
      # TODO don't request answer options from server if already present
      #if (is.null(answer_options[[.qid]])) {
        .current_answer_options = ls_getAnswerOptions(questionID = .qid, lang = lang)
        #append(answer_options, list(.qid = current_answer_options))
      #}
      if (nrow(.current_answer_options) > 0) for (.m in 1:nrow(.current_answer_options)) {
        .answer_code = paste0(.title, "___AO___", .current_answer_options[.m,]$answerCode)

        # catch answer option
        .answer_text = .current_answer_options[.m,]$answerText
        if (!is.na(.answer_text) && trimws(.answer_text) != "") {
          .df_row_answer_text = data.frame(paste0(.answer_code, "___answer_text"), .answer_text, "")
          names(.df_row_answer_text) = .col_names
          catalogue = rbind(catalogue, .df_row_answer_text)
        }
      }
    }

    # are there sub-questions?
    .sub_questions = arrange(filter(questions, parent_qid == .qid), question_order)
    if (nrow(.sub_questions) > 0) for (.l in 1:nrow(.sub_questions)) {
      .sq_title = paste0(.title, "___SQ___", .sub_questions[.l,]$title)

      # catch sub-question
      .sub_question = .sub_questions[.l,]$question
      if (!is.na(.sub_question) && trimws(.sub_question) != "") {
        .df_row_sub_question = data.frame(paste0(.sq_title, "___sub_question"), .sub_question, "")
        names(.df_row_sub_question) = .col_names
        catalogue = rbind(catalogue, .df_row_sub_question)
      }
    }

    # TODO question validation tips and other translatables from question properties
    # TODO other_replace_text (manually)
  }
}
```


## Get answer options for each "L" type question

```{r}
# Type "L" seems to be the question type for lists, those own answer options
filter(questions, type == "L")[,"qid"]

ls_getAnswerOptions("170", lang = lang)
```

## Export the catalogue data frame to Excel file

```{r}
if (!require("writexl")) install.packages("writexl")
library(writexl)
write_xlsx(catalogue, "./catalogue/catalogue.xlsx") # cwd = vignettes
# NOTE that to avoid confusion whether translation texts should be replaced or appended,
# we could lock: Excel > Review tab > Protection
# Check "Format cells..." with target text column marked: uncheck cell protection
remove(catalogue)
```


# Update translatables from spreadsheet

## Setup API connection

```{r}
lsGetSessionKey()
```

## Define target language

```{r}
lang = "vi"
.baseFileName = "./translations/lwc2-catalogue.2020-07-29.protected"
.xslxFileExt = ".xlsx"
```

## List questions

The questions data frame has to be up to date. Re-load to be sure. See above.

## Read Excel file

```{r}
if (!require("readxl")) install.packages("readxl")
library(readxl)
catalogue <- read_xlsx(paste0(.baseFileName, .xslxFileExt))
.translated <- read_xlsx(paste0(.baseFileName, ".", lang, .xslxFileExt)) %>% select(2)
# add translated to lang column to catalogue
.target_text_col_name = colnames(.translated)[1]
catalogue$target_text <- .translated[[.target_text_col_name]]
```

## Load translated texts into LimeSurvey

```{r}
for (.i in 1:nrow(catalogue)) {
  .text_id = catalogue[.i,]$text_id
  .a_text_id = str_split(.text_id, "___")
  .a_text_id_last = sapply(.a_text_id, tail, 1)
  .source_text = catalogue[.i,]$source_text
  .target_text = catalogue[.i,]$target_text
  .todo = TRUE

  if (.a_text_id_last == "welcome") {

    message(paste("setting surveyls_welcometext", .target_text, "lang = ", lang))
    message(lsSetLanguageProperties(surveyID = surveyID, lang = lang,
                            properties = list(surveyls_welcometext = .target_text))[2])
    .todo = FALSE

  } else if (.a_text_id_last == "policy_label") {

    message(paste("setting surveyls_policy_notice_label:", .target_text, "lang = ", lang))
    message(lsSetLanguageProperties(surveyID = surveyID, lang = lang,
                            properties = list(surveyls_policy_notice_label = .target_text))[2])
    .todo = FALSE

  } else if (.a_text_id_last == "policy_notice") {

    message(paste("setting surveyls_policy_notice:", .target_text, "lang = ", lang))
    message(lsSetLanguageProperties(surveyID = surveyID, lang = lang,
                            properties = list(surveyls_policy_notice = .target_text))[2])
    .todo = FALSE

  } else if (.a_text_id_last == "group_name") {

    # this is done elsewhere, see below
    .todo = FALSE

  } else if (.a_text_id_last == "question") {

    .question_title = .a_text_id[[1]][1]
    .qid = filter(questions, title == .question_title)$qid

    message(jsonlite::toJSON(list(task = "setting question", qid = .qid, title = .question_title,
                                  target_text = .target_text, lang = lang)))
    message(lsSetQuestionProperties(.qid, lang = lang, properties = list(question = .target_text)))

    .todo = FALSE

  } else if (.a_text_id_last == "answer_text") {

    # this is done elsewhere, see below
    .todo = FALSE

  } else if (.a_text_id_last == "sub_question") {

    .question_title = .a_text_id[[1]][1]
    .qid = filter(questions, title == .question_title)$qid
    .sub_question_title = .a_text_id[[1]][3]
    .sqid = filter(questions, title == .sub_question_title, parent_qid == .qid)$qid

    message(jsonlite::toJSON(list(task = "setting sub_question", qid = .sqid,
                                  parent_qid = .qid, title = .sub_question_title,
                                  target_text = .target_text, lang = lang)))
    message(lsSetQuestionProperties(.sqid, lang = lang, properties = list(question = .target_text)))

    .todo = FALSE

  } else if (.a_text_id_last == "help") {

    .question_title = .a_text_id[[1]][1]
    .qid = filter(questions, title == .question_title)$qid

    message(jsonlite::toJSON(list(task = "setting help", qid = .qid,
                                  title = .question_title,
                                  target_text = .target_text, lang = lang)))
    message(lsSetQuestionProperties(.qid, lang = lang, properties = list(help = .target_text)))

    .todo = FALSE

  } else if (.a_text_id_last == "other_field") {

    # this is done elsewhere, see below
    .todo = FALSE

  } else {

    stop(.a_text_id_last)
  }

  if (.todo) message(paste("TODO", .text_id, .a_text_id_last, .source_text, .target_text))
}

cat("Done.")
```

## Other fixes

```{r}
# set end URL (same as source)
.end_url = "https://lifewithcorona.org/"
message(paste("setting surveyls_url:", .end_url, "lang = ", lang))
message(lsSetLanguageProperties(surveyID = surveyID, lang = lang,
                                properties = list(surveyls_url = .end_url))[2])
```

## Workaround: manipulating the LSS file with PHP

### Answer options

Unfortunately, we cannot use the LimeSurvey JSON RPC API for updating group names
and answer options, so we create a translation data file to be used by a PHP script
that directly updates the LimeSurvey XML file (LSS).

```{r}
answer_options <-
  filter(catalogue, str_ends(text_id, "___answer_text")) %>%
  separate(col = text_id, into = c("title", "dropme", "answer_code"), sep = "___") %>%
  left_join(questions, by = "title") %>%
  select(-dropme, -parent_qid, -sid, -type, -question, -preg, -help, -other, -mandatory,
         -question_order, -scale_id, -same_default, -relevance, -modulename, -gid, -language)
write.csv(answer_options, file = paste0(.baseFileName, ".", lang, ".answer_options.csv"))
```

### Group names

```{r}
group_names <-
  filter(catalogue, str_ends(text_id, "___group_name")) %>%
  separate(col = text_id, into = c("dropme", "gid"), sep = "___") %>%
  select(-dropme)
write.csv(group_names, file = paste0(.baseFileName, ".", lang, ".group_names.csv"))
```

## Other fields

```{r}
other_fields <-
  filter(catalogue, str_ends(text_id, "___other_field")) %>%
  separate(col = text_id, into = c("title", "dropme"), sep = "___") %>%
  left_join(questions, by = "title") %>%
  select(-dropme, -parent_qid, -sid, -type, -question, -preg, -help, -other, -mandatory,
         -question_order, -scale_id, -same_default, -relevance, -modulename, -gid, -language)
write.csv(other_fields, file = paste0(.baseFileName, ".", lang, ".other_fields.csv"))
```
